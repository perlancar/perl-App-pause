#!perl

### begin code_after_shebang
### end code_after_shebang
# PERICMD_INLINE_SCRIPT: {"code_add_extra_log_outputs":"...","code_before_enable_logging":"...","config_filename":["pause.conf"],"env_name":"PAUSE_OPT","include":[],"log":1,"pack_deps":0,"pod":0,"read_config":1,"read_env":1,"script_name":"pause","script_summary":"A CLI for PAUSE","script_version_from_main_version":1,"shebang":"#!perl","subcommands":{"cleanup":{"url":"/WWW/PAUSE/Simple/delete_old_releases"},"ls":{"url":"/WWW/PAUSE/Simple/list_files"},"ls-dists":{"url":"/WWW/PAUSE/Simple/list_dists"},"ls-mods":{"url":"/WWW/PAUSE/Simple/list_modules"},"reindex":{"url":"/WWW/PAUSE/Simple/reindex_files"},"rm":{"url":"/WWW/PAUSE/Simple/delete_files"},"undelete":{"url":"/WWW/PAUSE/Simple/undelete_files"},"upload":{"url":"/WWW/PAUSE/Simple/upload_files"}},"url":"/WWW/PAUSE/Simple/","use_cleanser":0,"validate_args":1}

# This script is generated by Perinci::CmdLine::Inline version 0.554 on Sun Jan 16 23:26:11 2022.

# Rinci metadata taken from these modules: WWW::PAUSE::Simple 0.452

# You probably should not manually edit this file.

## no critic: TestingAndDebugging::RequireUseStrict

# PODNAME: pause
# ABSTRACT: A CLI for PAUSE

package main;
use 5.010001;
use strict;
#use warnings;

# load modules


### declare global variables

# AUTHORITY
# DATE
# DIST
# VERSION

my $_pci_metas = do{my$var={cleanup=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{}],summary=>"Whether to return detailed records"},include_dev=>{default=>0,schema=>["bool",{req=>1}],summary=>"Whether to include cleaning up non-dev releases"},include_nondev=>{default=>1,schema=>["bool",{req=>1}],summary=>"Whether to include cleaning up non-dev releases"},num_keep=>{cmdline_aliases=>{n=>{}},default=>1,description=>"\n1 means to only keep the newest version, 2 means to keep the newest and the\nsecond newest, and so on.\n\n",schema=>["int",{min=>1,req=>1}],summary=>"Number of new versions (including newest) to keep"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>["common"]},protect_files=>{schema=>["array",{of=>["str",{req=>1}],req=>1}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>["category:filtering"],"x.name.is_plural"=>1},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>["common"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>["common"]}},description=>"\nCurrently does not look for releases in subdirectories.\n\nBy default does not include developer (trial) releases. To include that, use\n`--include-dev`.\n\nTo only cleanup developer releases, you can use `--include-dev` and\n`--exclude-nondev`.\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete older versions of distributions",v=>1.1},ls=>{args=>{del=>{schema=>["bool",{}],summary=>"Only list files which are scheduled for deletion","summary.alt.bool.not"=>"Only list files which are not scheduled for deletion",tags=>["category:filtering"]},detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{}],summary=>"Whether to return detailed records"},files=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1}],req=>1}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},mtime_max=>{schema=>["date",{req=>1,"x.perl.coerce_to"=>"float(epoch)"}],tags=>["category:filtering"]},mtime_min=>{schema=>["date",{req=>1,"x.perl.coerce_to"=>"float(epoch)"}],tags=>["category:filtering"]},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},size_max=>{schema=>["uint",{req=>1}],tags=>["category:filtering"]},size_min=>{schema=>["uint",{req=>1}],tags=>["category:filtering"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},result=>{},summary=>"List files",v=>1.1},"ls-dists"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{}],summary=>"Whether to return detailed records"},include_dev=>{schema=>["bool",{req=>1}]},include_nondev=>{default=>1,schema=>["bool",{req=>1}]},newest=>{description=>"\nDev versions will be skipped.\n\n",schema=>["bool",{}],summary=>"Only show newest non-dev version"},newest_n=>{description=>"\nDev versions will be skipped.\n\n",schema=>["int",{min=>1,req=>1}],summary=>"Only show this number of newest versions"},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},description=>"\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\n",result=>{},summary=>"List distributions",v=>1.1},"ls-mods"=>{args=>{detail=>{cmdline_aliases=>{l=>{}},schema=>["bool",{}],summary=>"Whether to return detailed records"},modules=>{greedy=>1,pos=>0,schema=>["array",{of=>["str",{req=>1}],req=>1}],summary=>"Module names/wildcard patterns","summary.alt.plurality.singular"=>"Module name/wildcard pattern",tags=>["category:filtering"],"x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},type=>{schema=>["str",{req=>1}],summary=>"Only list modules matching certain type",tags=>["category:filtering"]},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},result=>{},summary=>"List modules (permissions)",v=>1.1},reindex=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1}],req=>1}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},features=>{dry_run=>1},result=>{},summary=>"Force reindexing",v=>1.1},rm=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1}],req=>1}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},protect_files=>{schema=>["array",{of=>["str",{req=>1}],req=>1}],summary=>"Protect some files/wildcard patterns from delete/cleanup",tags=>'$var->{cleanup}{args}{protect_files}{tags}',"x.name.is_plural"=>1},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Delete files",v=>1.1},undelete=>{args=>{files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1}],req=>1}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},description=>"\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\n",features=>{dry_run=>1},result=>{},summary=>"Undelete files",v=>1.1},upload=>{args=>{delay=>{description=>"\nIf you upload a lot of files (e.g. 7-10 or more) at a time, the PAUSE indexer\ncurrently might choke with SQLite database locking problem and thus fail to\nindex your releases. Giving a delay of say 2-3 minutes (120-180 seconds) between\nfiles will alleviate this problem.\n\n",schema=>["duration",{req=>1}],summary=>"Pause a number of seconds between files"},files=>{greedy=>1,pos=>0,req=>1,schema=>["array",{min_len=>1,of=>["str",{req=>1}],req=>1}],summary=>"File names/wildcard patterns","summary.alt.plurality.singular"=>"File name/wildcard pattern","x.name.is_plural"=>1},password=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",is_password=>1,schema=>["str",{req=>1}],summary=>"PAUSE password",tags=>'$var->{cleanup}{args}{password}{tags}'},retries=>{default=>5,description=>"\nThe retry uses an exponential backoff strategy of delaying 3, 6, 12, 24, ...,\n3600, 3600, ... seconds.\n\n",schema=>["int",{req=>1}],summary=>"Number of retries when received 5xx HTTP error from server",tags=>'$var->{cleanup}{args}{retries}{tags}'},subdir=>{default=>"",schema=>["str",{req=>1}],summary=>"Subdirectory to put the file(s) into"},username=>{description=>"\nIf unset, default value will be searched from `~/.pause`. Encrypted `.pause` is\nnot yet supported.\n\n",schema=>["str",{match=>"\\A\\w{2,9}\\z",max_len=>9,req=>1}],summary=>"PAUSE ID",tags=>'$var->{cleanup}{args}{username}{tags}'}},args_rels=>{choose_one=>["delay"]},features=>{dry_run=>1},result=>{},summary=>"Upload file(s)",v=>1.1}};$var->{ls}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{ls}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{ls}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{"ls-dists"}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{"ls-dists"}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{"ls-dists"}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{"ls-mods"}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{"ls-mods"}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{"ls-mods"}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{reindex}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{reindex}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{reindex}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{rm}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{rm}{args}{protect_files}{tags}=$var->{cleanup}{args}{protect_files}{tags};$var->{rm}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{rm}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{undelete}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{undelete}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{undelete}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var->{upload}{args}{password}{tags}=$var->{cleanup}{args}{password}{tags};$var->{upload}{args}{retries}{tags}=$var->{cleanup}{args}{retries}{tags};$var->{upload}{args}{username}{tags}=$var->{cleanup}{args}{username}{tags};$var};

our $_pci_log_outputs = {};
our $_pci_meta_result_stream = 0;
our $_pci_meta_result_type;
our $_pci_meta_result_type_is_simple;
our $_pci_meta_skip_format = 0;
our $_pci_r = {naked_res=>0,read_config=>1,read_env=>1,subcommand_name=>""};
our %_pci_args;

### begin code_before_enable_logging
require Log::ger::Layout::JSON;
### end code_before_enable_logging
### enable logging
$_pci_log_outputs->{Screen} = { conf => { colorize_tags => 1, formatter => sub { "pause: " . $_[0] } } };
#### begin code_add_extra_log_outputs
$_pci_log_outputs->{Screen}{category_level}{_access} = "off"; $_pci_log_outputs->{SimpleFile} = {conf=>{path => ($ENV{HOME} || ".")."/pause-access.log"}, level=>"off", layout=>[JSON=>{}], category_level=>{_access=>"info"}}; 
#### end code_add_extra_log_outputs
require Log::ger::Output; Log::ger::Output->set("Composite", outputs => $_pci_log_outputs);
require Log::ger; Log::ger->import;

### begin code_after_enable_logging
### end code_after_enable_logging
### declare subroutines

sub _pci_err {
    my $res = shift;
    print STDERR "ERROR $res->[0]: $res->[1]\n";
    exit $res->[0]-300;
}

sub _pci_json {
    state $json = do {
        if (eval { require JSON::XS; 1 }) { JSON::XS->new->canonical(1)->allow_nonref }
        else { require JSON::PP; JSON::PP->new->canonical(1)->allow_nonref }
    };
    $json;
}

### begin code_before_parse_cmdline_options
### end code_before_parse_cmdline_options
### get arguments (from config file, env, command-line args

{
my %mentioned_args;
require Getopt::Long::EvenLess;
log_trace("Parsing command-line arguments ...");
require Getopt::Long::Subcommand;
my $help_msg = "pause - A CLI for PAUSE\n\nUsage:\n  pause --help (or -h, -?)\n  pause --subcommands\n  pause --version (or -v)\n  pause [--cmd=subcommand_name] [(--config-path=path)+|--no-config]\n    [--config-profile=profile] [--debug] [--format=name|--json] [--log-level=s]\n    [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--quiet] [--trace] [--verbose]\n\nSubcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --cmd=s                        Select subcommand\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --quiet                        Set logging level to error\n  --subcommands                  List available subcommands\n  --trace                        Set logging level to trace\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n";
my $go_spec1 = {
  'cmd=s' => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
  'config-path=s@' => sub { $_pci_r->{config_paths} //= []; push @{ $_pci_r->{config_paths} }, $_[1]; },
  'config-profile=s' => sub { $_pci_r->{config_profile} = $_[1]; },
  'debug' => sub { require Log::ger::Util; Log::ger::Util::set_level("debug"); $_pci_r->{log_level} = "debug"; },
  'format=s' => sub { $_pci_r->{format} = $_[1]; },
  'help|h|?' => sub { my $sc_name = $_pci_r->{subcommand_name}; my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $sc_name && defined $first_non_opt_arg) { $sc_name = $first_non_opt_arg } if (!length $sc_name) { print $help_msg } elsif ($sc_name eq "") { print "pause - A CLI for PAUSE\n\nUsage:\n  pause --help (or -h, -?)\n  pause --subcommands\n  pause --version (or -v)\n  pause [--cmd=subcommand_name] [(--config-path=path)+|--no-config]\n    [--config-profile=profile] [--debug] [--format=name|--json] [--log-level=s]\n    [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--quiet] [--trace] [--verbose]\n\nSubcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --cmd=s                        Select subcommand\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --quiet                        Set logging level to error\n  --subcommands                  List available subcommands\n  --trace                        Set logging level to trace\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "cleanup") { print "pause cleanup - Delete older versions of distributions\n\nUsage:\n  pause cleanup --help (or -h, -?)\n  pause cleanup --version (or -v)\n  pause cleanup [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--detail|-l|--no-detail|--nodetail] [--format=name|--json]\n    [--include-dev|--exclude-dev] [--include-nondev|--exclude-nondev]\n    [--log-level=s] [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--num-keep=int] [--page-result[=program]] [--password=str]\n    [(--protect-file=str)+] [--quiet] [--retries=int] [--trace]\n    [--username=str] [--verbose] [-n=int]\n\nCurrently does not look for releases in subdirectories.\n\nBy default does not include developer (trial) releases. To include that, use\n`--include-dev`.\n\nTo only cleanup developer releases, you can use `--include-dev` and\n`--exclude-nondev`.\n\nMain options:\n  --detail, -l      Whether to return detailed records\n  --exclude-nondev  \n  --include-dev     Whether to include cleaning up non-dev releases\n  --num-keep=s, -n  Number of new versions (including newest) to keep [1]\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls") { print "pause ls - List files\n\nUsage:\n  pause ls --help (or -h, -?)\n  pause ls --version (or -v)\n  pause ls [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--del|--no-del|--nodel] [--detail|-l|--no-detail|--nodetail]\n    [--format=name|--json] [--log-level=s] [--mtime-max=date]\n    [--mtime-min=date] [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--password=str] [--quiet] [--retries=int]\n    [--size-max=uint] [--size-min=uint] [--trace] [--username=str] [--verbose]\n    -- [files] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --del          Only list files which are scheduled for deletion\n  --file=s\@      File name/wildcard pattern (=arg[0-])\n  --mtime-max=s  \n  --mtime-min=s  \n  --size-max=s   \n  --size-min=s   \n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls-dists") { print "pause ls-dists - List distributions\n\nUsage:\n  pause ls-dists --help (or -h, -?)\n  pause ls-dists --version (or -v)\n  pause ls-dists [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--detail|-l|--no-detail|--nodetail] [--format=name|--json]\n    [--include-dev|--exclude-dev] [--include-nondev|--exclude-nondev]\n    [--log-level=s] [--naked-res] [--newest|--no-newest|--nonewest]\n    [--newest-n=int] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--password=str] [--quiet] [--retries=int]\n    [--trace] [--username=str] [--verbose]\n\nDistribution names will be extracted from tarball/zip filenames.\n\nUnknown/unparseable filenames will be skipped.\n\nMain options:\n  --detail, -l      Whether to return detailed records\n  --exclude-nondev  \n  --include-dev     \n  --newest          Only show newest non-dev version\n  --newest-n=s      Only show this number of newest versions\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "ls-mods") { print "pause ls-mods - List modules (permissions)\n\nUsage:\n  pause ls-mods --help (or -h, -?)\n  pause ls-mods --version (or -v)\n  pause ls-mods [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--detail|-l|--no-detail|--nodetail] [--format=name|--json]\n    [--log-level=s] [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--password=str] [--quiet] [--retries=int]\n    [--trace] [--type=str] [--username=str] [--verbose] -- [modules] ...\n\nMain options:\n  --detail, -l  Whether to return detailed records\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --module=s\@  Module name/wildcard pattern (=arg[0-])\n  --type=s     Only list modules matching certain type\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "reindex") { print "pause reindex - Force reindexing\n\nUsage:\n  pause reindex --help (or -h, -?)\n  pause reindex --version (or -v)\n  pause reindex [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--format=name|--json] [--log-level=s] [--naked-res] [--no-env]\n    [--no-naked-res|--nonaked-res] [--page-result[=program]] [--password=str]\n    [--quiet] [--retries=int] [--trace] [--username=str] [--verbose] -- <files>\n    ...\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "rm") { print "pause rm - Delete files\n\nUsage:\n  pause rm --help (or -h, -?)\n  pause rm --version (or -v)\n  pause rm [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--format=name|--json] [--log-level=s] [--naked-res] [--no-env]\n    [--no-naked-res|--nonaked-res] [--page-result[=program]] [--password=str]\n    [(--protect-file=str)+] [--quiet] [--retries=int] [--trace]\n    [--username=str] [--verbose] -- <files> ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nFiltering options:\n  --protect-file=s\@  Protect some files/wildcard patterns from delete/cleanup\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "undelete") { print "pause undelete - Undelete files\n\nUsage:\n  pause undelete --help (or -h, -?)\n  pause undelete --version (or -v)\n  pause undelete [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--format=name|--json] [--log-level=s] [--naked-res] [--no-env]\n    [--no-naked-res|--nonaked-res] [--page-result[=program]] [--password=str]\n    [--quiet] [--retries=int] [--trace] [--username=str] [--verbose] -- <files>\n    ...\n\nWhen a file is deleted, it is not immediately deleted but has\nscheduled_for_deletion status for 72 hours, then deleted. During that time, the\nfile can be undeleted.\n\nMain options:\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } elsif ($sc_name eq "upload") { print "pause upload - Upload file(s)\n\nUsage:\n  pause upload --help (or -h, -?)\n  pause upload --version (or -v)\n  pause upload [(--config-path=path)+|--no-config] [--config-profile=profile]\n    [--debug] [--delay=duration] [--format=name|--json] [--log-level=s]\n    [--naked-res] [--no-env] [--no-naked-res|--nonaked-res]\n    [--page-result[=program]] [--password=str] [--quiet] [--retries=int]\n    [--subdir=str] [--trace] [--username=str] [--verbose] -- <files> ...\n\nMain options:\n  --delay=s   Pause a number of seconds between files\n  --file=s\@*  File name/wildcard pattern (=arg[0-])\n  --subdir=s  Subdirectory to put the file(s) into [\"\"]\n\nConfiguration options:\n  --config-path=s     Set path to configuration file\n  --config-profile=s  Set configuration profile to use\n  --no-config         Do not use any configuration file\n\nEnvironment options:\n  --no-env  Do not read environment for default options\n\nOutput options:\n  --format=s     Choose output format, e.g. json, text\n  --json         Set output format to json\n  --page-result  Filter output through a pager\n\nOther options:\n  --debug                        Set logging level to debug\n  --help, -h, -?                 Display help message and exit\n  --log-level=s                  Set logging level (trace|debug|info|warn|error|fatal|none)\n  --naked-res                    When outputing as JSON, strip result envelope\n  --no-naked-res, --nonaked-res  When outputing as JSON, don't strip result envelope\n  --password=s                   PAUSE password\n  --quiet                        Set logging level to error\n  --retries=s                    Number of retries when received 5xx HTTP error from server [5]\n  --trace                        Set logging level to trace\n  --username=s                   PAUSE ID\n  --verbose                      Set logging level to info\n  --version, -v                  Display program's version and exit\n" } else { _pci_err([500, "Unknown subcommand2: $sc_name"]) } exit 0 },
  'json' => sub { $_pci_r->{format} = (-t STDOUT) ? "json-pretty" : "json"; ## no critic InputOutput::ProhibitInteractiveTest
 },
  'log-level=s' => sub { if ($_[1] eq "trace") { require Log::ger::Util; Log::ger::Util::set_level("trace"); Log::ger::Output::Composite::set_level("trace") } if ($_[1] eq "debug") { require Log::ger::Util; Log::ger::Util::set_level("debug"); Log::ger::Output::Composite::set_level("debug") } if ($_[1] eq "info" ) { require Log::ger::Util; Log::ger::Util::set_level("info" ); Log::ger::Output::Composite::set_level("info")  } if ($_[1] eq "error") { require Log::ger::Util; Log::ger::Util::set_level("warn" ); Log::ger::Output::Composite::set_level("warn")  } if ($_[1] eq "fatal") { require Log::ger::Util; Log::ger::Util::set_level("debug"); Log::ger::Output::Composite::set_level("debug") } if ($_[1] eq "none")  { require Log::ger::Util; Log::ger::Util::set_level("off"  ); Log::ger::Output::Composite::set_level("off")   } if ($_[1] eq "off")   { require Log::ger::Util; Log::ger::Util::set_level("off"  ); Log::ger::Output::Composite::set_level("off")   } $_pci_r->{log_level} = $_[1]; },
  'naked-res' => sub { $_pci_r->{naked_res} = 1; },
  'no-config' => sub { $_pci_r->{read_config} = 0; },
  'no-env' => sub { $_pci_r->{read_env} = 0; },
  'no-naked-res|nonaked-res' => sub { $_pci_r->{naked_res} = 0; },
  'page-result:s' => sub { $_pci_r->{page_result} = 1; },
  'quiet' => sub { require Log::ger::Util; Log::ger::Util::set_level("error"); $_pci_r->{log_level} = "error"; },
  'subcommands' => sub { print "Available subcommands:\n  cleanup\n  ls\n  ls-dists\n  ls-mods\n  reindex\n  rm\n  undelete\n  upload\n"; exit 0 },
  'trace' => sub { require Log::ger::Util; Log::ger::Util::set_level("trace"); $_pci_r->{log_level} = "trace"; },
  'verbose' => sub { require Log::ger::Util; Log::ger::Util::set_level("info" ); $_pci_r->{log_level} = "info" ; },
  'version|v' => sub { no warnings 'once'; require WWW::PAUSE::Simple; print "pause version ", $main::VERSION // '?', ($main::DATE ? " ($main::DATE)" : ''), "\n"; print "  Generated by Perinci::CmdLine::Inline version 0.554 (2022-01-16)\n"; exit 0 },
};
my $go_spec2 = {
  options => {
    'cmd=s' => {
      handler => sub { $_[2]{subcommand} = [$_[1]]; $_pci_r->{subcommand_name} = $_[1]; },
    },
    'config-path=s@' => {
      handler => sub {},
    },
    'config-profile=s' => {
      handler => sub {},
    },
    'debug' => {
      handler => sub {},
    },
    'format=s' => {
      handler => sub {},
    },
    'help|h|?' => {
      handler => sub {},
    },
    'json' => {
      handler => sub {},
    },
    'log-level=s' => {
      handler => sub {},
    },
    'naked-res' => {
      handler => sub {},
    },
    'no-config' => {
      handler => sub {},
    },
    'no-env' => {
      handler => sub {},
    },
    'no-naked-res|nonaked-res' => {
      handler => sub {},
    },
    'page-result:s' => {
      handler => sub {},
    },
    'quiet' => {
      handler => sub {},
    },
    'subcommands' => {
      handler => sub {},
    },
    'trace' => {
      handler => sub {},
    },
    'verbose' => {
      handler => sub {},
    },
    'version|v' => {
      handler => sub {},
    },
  },
  subcommands => {
    'cleanup' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'exclude-dev' => {
          handler => sub { $_pci_args{'include_dev'} = 0; },
        },
        'exclude-nondev' => {
          handler => sub { $_pci_args{'include_nondev'} = 0; },
        },
        'include-dev' => {
          handler => sub { $_pci_args{'include_dev'} = $_[1]; },
        },
        'include-nondev' => {
          handler => sub { $_pci_args{'include_nondev'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'n=s' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'num-keep=s' => {
          handler => sub { $_pci_args{'num_keep'} = $_[1]; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls' => {
      options => {
        'del' => {
          handler => sub { $_pci_args{'del'} = $_[1]; },
        },
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'mtime-max=s' => {
          handler => sub { $_pci_args{'mtime_max'} = $_[1]; },
        },
        'mtime-min=s' => {
          handler => sub { $_pci_args{'mtime_min'} = $_[1]; },
        },
        'no-del' => {
          handler => sub { $_pci_args{'del'} = 0; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'nodel' => {
          handler => sub { $_pci_args{'del'} = 0; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'size-max=s' => {
          handler => sub { $_pci_args{'size_max'} = $_[1]; },
        },
        'size-min=s' => {
          handler => sub { $_pci_args{'size_min'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls-dists' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'exclude-dev' => {
          handler => sub { $_pci_args{'include_dev'} = 0; },
        },
        'exclude-nondev' => {
          handler => sub { $_pci_args{'include_nondev'} = 0; },
        },
        'include-dev' => {
          handler => sub { $_pci_args{'include_dev'} = $_[1]; },
        },
        'include-nondev' => {
          handler => sub { $_pci_args{'include_nondev'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'newest' => {
          handler => sub { $_pci_args{'newest'} = $_[1]; },
        },
        'newest-n=s' => {
          handler => sub { $_pci_args{'newest_n'} = $_[1]; },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'no-newest' => {
          handler => sub { $_pci_args{'newest'} = 0; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'nonewest' => {
          handler => sub { $_pci_args{'newest'} = 0; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'ls-mods' => {
      options => {
        'detail' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'l' => {
          handler => sub { $_pci_args{'detail'} = $_[1]; },
        },
        'module=s@' => {
          handler => sub { if ($mentioned_args{'modules'}++) { push @{ $_pci_args{'modules'} }, $_[1] } else { $_pci_args{'modules'} = [$_[1]] } },
        },
        'modules-json=s' => {
          handler => sub { $_pci_args{'modules'} = _pci_json()->decode($_[1]); },
        },
        'no-detail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'nodetail' => {
          handler => sub { $_pci_args{'detail'} = 0; },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'type=s' => {
          handler => sub { $_pci_args{'type'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'reindex' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'rm' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'protect-file=s@' => {
          handler => sub { if ($mentioned_args{'protect_files'}++) { push @{ $_pci_args{'protect_files'} }, $_[1] } else { $_pci_args{'protect_files'} = [$_[1]] } },
        },
        'protect-files-json=s' => {
          handler => sub { $_pci_args{'protect_files'} = _pci_json()->decode($_[1]); },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'undelete' => {
      options => {
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
    'upload' => {
      options => {
        'delay=s' => {
          handler => sub { $_pci_args{'delay'} = $_[1]; },
        },
        'file=s@' => {
          handler => sub { if ($mentioned_args{'files'}++) { push @{ $_pci_args{'files'} }, $_[1] } else { $_pci_args{'files'} = [$_[1]] } },
        },
        'files-json=s' => {
          handler => sub { $_pci_args{'files'} = _pci_json()->decode($_[1]); },
        },
        'password=s' => {
          handler => sub { $_pci_args{'password'} = $_[1]; },
        },
        'retries=s' => {
          handler => sub { $_pci_args{'retries'} = $_[1]; },
        },
        'subdir=s' => {
          handler => sub { $_pci_args{'subdir'} = $_[1]; },
        },
        'username=s' => {
          handler => sub { $_pci_args{'username'} = $_[1]; },
        },
      },
    },
  },
  default_subcommand => undef,
};
{
  local @ARGV = @ARGV;
  my $old_conf = Getopt::Long::EvenLess::Configure("pass_through");
  Getopt::Long::EvenLess::GetOptions(%$go_spec1);
  Getopt::Long::EvenLess::Configure($old_conf);
  { my $first_non_opt_arg; for (@ARGV) { next if /^-/; $first_non_opt_arg = $_; last } if (!length $_pci_r->{subcommand_name} && defined $first_non_opt_arg) { $_pci_r->{subcommand_name} = $first_non_opt_arg } }
}
{
  last unless $_pci_r->{read_env};
  my $env = $ENV{"PAUSE_OPT"};
  last unless defined $env;
  require Complete::Bash;
  my ($words, undef) = @{ Complete::Bash::parse_cmdline($env, 0) };
  unshift @ARGV, @$words;
}
if ($_pci_r->{read_config}) {
log_trace("Reading config file(s) ...");
  require Perinci::CmdLine::Util::Config;

  my $res = Perinci::CmdLine::Util::Config::read_config(
    config_paths     => $_pci_r->{config_paths},
    config_filename  => ["pause.conf"],
    config_dirs      => undef // ["$ENV{HOME}/.config", $ENV{HOME}, "/etc"],
    program_name     => "pause",
  );
  _pci_err($res) unless $res->[0] == 200;
  $_pci_r->{config} = $res->[2];
  $_pci_r->{read_config_files} = $res->[3]{"func.read_files"};
  $_pci_r->{_config_section_read_order} = $res->[3]{"func.section_read_order"}; # we currently dont want to publish this request key

  $res = Perinci::CmdLine::Util::Config::get_args_from_config(
    r                  => $_pci_r,
    config             => $_pci_r->{config},
    args               => \%_pci_args,
    program_name       => "pause",
    subcommand_name    => $_pci_r->{subcommand_name},
    config_profile     => $_pci_r->{config_profile},
    common_opts        => {},
    meta               => $_pci_metas->{ $_pci_r->{subcommand_name} },
    meta_is_normalized => 1,
  );
  die $res unless $res->[0] == 200;
  my $found = $res->[3]{"func.found"};
  if (defined($_pci_r->{config_profile}) && !$found && defined($_pci_r->{read_config_files}) && @{$_pci_r->{read_config_files}} && !$_pci_r->{ignore_missing_config_profile_section}) {
    _pci_err([412, "Profile '$_pci_r->{config_profile}' not found in configuration file"]);
  }
}
my $res = Getopt::Long::Subcommand::GetOptions(%$go_spec2);
_pci_err([500, "GetOptions failed"]) unless $res->{success};
if (!length $_pci_r->{subcommand_name}) { print $help_msg; exit 0 }
}

### check arguments

{
my $res = _pci_check_args(\%_pci_args);
_pci_err($res) if $res->[0] != 200;
$_pci_r->{args} = \%_pci_args;
}

### call function

{
log_trace("Calling function ...");
my $sc_name = $_pci_r->{subcommand_name};
if ($sc_name eq "cleanup") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_old_releases(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_files(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls-dists") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_dists(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "ls-mods") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::list_modules(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "reindex") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::reindex_files(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "rm") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::delete_files(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "undelete") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::undelete_files(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
elsif ($sc_name eq "upload") {
    $_pci_meta_result_type = "";
    require WWW::PAUSE::Simple;
    eval { $_pci_r->{res} = WWW::PAUSE::Simple::upload_files(%_pci_args) };
    if ($@) { die if $ENV{PERINCI_CMDLINE_INLINE_DEBUG_DIE}; $_pci_r->{res} = [500, "Function died: $@"] }
}
}

### format & display result

{
log_trace("Displaying result ...");
my $fh;
if ($_pci_r->{page_result} // $ENV{PAGE_RESULT} // $_pci_r->{res}[3]{"cmdline.page_result"}) {
my $pager = $_pci_r->{pager} // $_pci_r->{res}[3]{"cmdline.pager"} // $ENV{PAGER} // "less -FRSX";
open $fh, "| $pager"; ## no critic InputOutput::ProhibitTwoArgOpen
} else {
$fh = \*STDOUT;
}
my $fres;
my $save_res; if (exists $_pci_r->{res}[3]{"cmdline.result"}) { $save_res = $_pci_r->{res}[2]; $_pci_r->{res}[2] = $_pci_r->{res}[3]{"cmdline.result"} }
my $is_success = $_pci_r->{res}[0] =~ /\A2/ || $_pci_r->{res}[0] == 304;
my $is_stream = $_pci_r->{res}[3]{stream} // $_pci_meta_result_stream // 0;
if ($is_success && (0 || $_pci_meta_skip_format || $_pci_r->{res}[3]{"cmdline.skip_format"})) { $fres = $_pci_r->{res}[2] }
elsif ($is_success && $is_stream) {}
else { require Perinci::Result::Format::Lite; $is_stream=0; $fres = Perinci::Result::Format::Lite::format($_pci_r->{res}, ($_pci_r->{format} // $_pci_r->{res}[3]{"cmdline.default_format"} // "text"), $_pci_r->{naked_res}, 0) }

my $use_utf8 = $_pci_r->{res}[3]{"x.hint.result_binary"} ? 0 : 0;
if ($use_utf8) { binmode STDOUT, ":encoding(utf8)" }
if ($is_stream) {
    my $code = $_pci_r->{res}[2]; if (ref($code) ne "CODE") { die "Result is a stream but no coderef provided" } if ($_pci_meta_result_type_is_simple) { while(defined(my $l=$code->())) { print $fh $l; print $fh "\n" unless $_pci_meta_result_type eq "buf"; } } else { while (defined(my $rec=$code->())) { if (!defined($rec) || ref $rec) { print $fh _pci_json()->encode($rec),"\n" } else { print $fh $rec,"\n" } } }
} else {
    print $fh $fres;
}
if (defined $save_res) { $_pci_r->{res}[2] = $save_res }
}

### exit

{
my $status = $_pci_r->{res}[0];
my $exit_code = $_pci_r->{res}[3]{"cmdline.exit_code"} // ($status =~ /200|304/ ? 0 : ($status-300));
exit($exit_code);
}

# BEGIN Local::_pci_check_args
sub _pci_check_args {
    my ($args) = @_;
    my $sc_name = $_pci_r->{subcommand_name};
    if ($sc_name eq "cleanup") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require Scalar::Util::Numeric::PP;
        require List::Util;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"detail"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"detail"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"detail"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"include_dev"} //= 0;
        if (exists $args->{"include_dev"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"include_dev"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'bool'
            ((!ref($args->{"include_dev"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"include_nondev"} //= 1;
        if (exists $args->{"include_nondev"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"include_nondev"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'bool'
            ((!ref($args->{"include_nondev"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"num_keep"} //= 1;
        if (exists $args->{"num_keep"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"num_keep"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"num_keep"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
            
            &&
            
            (# clause: min
            (($args->{"num_keep"} >= 1) ? 1 : (($_sahv_err //= "Must be at least 1"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"protect_files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"protect_files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"protect_files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"protect_files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"protect_files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"protect_files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required value for argument: include_dev"] if exists($args->{"include_dev"}) && !defined($args->{"include_dev"});
        return [400, "Missing required value for argument: include_nondev"] if exists($args->{"include_nondev"}) && !defined($args->{"include_nondev"});
        return [400, "Missing required value for argument: num_keep"] if exists($args->{"num_keep"}) && !defined($args->{"num_keep"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require List::Util;
        require Time::Local;
        require Scalar::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"del"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"del"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"del"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"detail"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"detail"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"detail"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"mtime_max"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"mtime_max"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # coerce rule(s): From_float::epoch, From_obj::datetime, From_obj::time_moment, From_str::iso8601 # coerce to: float(epoch)
            (($args->{"mtime_max"} = (!ref($args->{"mtime_max"}) && $args->{"mtime_max"} =~ /\A[0-9]{8,10}(?:.[0-9]+)?\z/ && $args->{"mtime_max"} >= 10**8 && $args->{"mtime_max"} <= 2**31) ? [undef,$args->{"mtime_max"}] : ((Scalar::Util::blessed($args->{"mtime_max"}) && $args->{"mtime_max"}->isa('DateTime')) ? [undef,$args->{"mtime_max"}->epoch] : ((Scalar::Util::blessed($args->{"mtime_max"}) && $args->{"mtime_max"}->isa('Time::Moment')) ? [undef,$args->{"mtime_max"}->epoch] : ((!ref($args->{"mtime_max"}) && $args->{"mtime_max"} =~ /\A([0-9]{4})-([0-9]{2})-([0-9]{2})(?:([T ])([0-9]{2}):([0-9]{2}):([0-9]{2})(Z?))?\z/) ? (do { my $time; eval { $time = $8 ? Time::Local::timegm_modern($7, $6, $5, $3, $2-1, $1) : $4 ? Time::Local::timelocal_modern($7, $6, $5, $3, $2-1, $1) : Time::Local::timelocal_modern(0, 0, 0, $3, $2-1, $1) }; my $err = $@; if ($err) { $err =~ s/ at .+//s; ["Invalid date/time: $err", $time] } else { [undef, $time] } }) : [undef,$args->{"mtime_max"}])))), defined($args->{"mtime_max"}->[0]) ? (($_sahv_err //= $args->{"mtime_max"}->[0]), ($args->{"mtime_max"} = $args->{"mtime_max"}->[1]), '') : (($args->{"mtime_max"} = $args->{"mtime_max"}->[1]), 1))
            
            &&
            
            # check type 'date'
            ((!ref($args->{"mtime_max"}) && $args->{"mtime_max"} =~ /\A[0-9]+\z/) ? 1 : (($_sahv_err //= "Not of type date"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"mtime_min"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"mtime_min"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # coerce rule(s): From_float::epoch, From_obj::datetime, From_obj::time_moment, From_str::iso8601 # coerce to: float(epoch)
            (($args->{"mtime_min"} = (!ref($args->{"mtime_min"}) && $args->{"mtime_min"} =~ /\A[0-9]{8,10}(?:.[0-9]+)?\z/ && $args->{"mtime_min"} >= 10**8 && $args->{"mtime_min"} <= 2**31) ? [undef,$args->{"mtime_min"}] : ((Scalar::Util::blessed($args->{"mtime_min"}) && $args->{"mtime_min"}->isa('DateTime')) ? [undef,$args->{"mtime_min"}->epoch] : ((Scalar::Util::blessed($args->{"mtime_min"}) && $args->{"mtime_min"}->isa('Time::Moment')) ? [undef,$args->{"mtime_min"}->epoch] : ((!ref($args->{"mtime_min"}) && $args->{"mtime_min"} =~ /\A([0-9]{4})-([0-9]{2})-([0-9]{2})(?:([T ])([0-9]{2}):([0-9]{2}):([0-9]{2})(Z?))?\z/) ? (do { my $time; eval { $time = $8 ? Time::Local::timegm_modern($7, $6, $5, $3, $2-1, $1) : $4 ? Time::Local::timelocal_modern($7, $6, $5, $3, $2-1, $1) : Time::Local::timelocal_modern(0, 0, 0, $3, $2-1, $1) }; my $err = $@; if ($err) { $err =~ s/ at .+//s; ["Invalid date/time: $err", $time] } else { [undef, $time] } }) : [undef,$args->{"mtime_min"}])))), defined($args->{"mtime_min"}->[0]) ? (($_sahv_err //= $args->{"mtime_min"}->[0]), ($args->{"mtime_min"} = $args->{"mtime_min"}->[1]), '') : (($args->{"mtime_min"} = $args->{"mtime_min"}->[1]), 1))
            
            &&
            
            # check type 'date'
            ((!ref($args->{"mtime_min"}) && $args->{"mtime_min"} =~ /\A[0-9]+\z/) ? 1 : (($_sahv_err //= "Not of type date"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"size_max"}) {
            $_sahv_dpath = [];
            # req #1
            ((defined($args->{"size_max"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"size_max"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
            
            &&
            
            (# clause: min
            (($args->{"size_max"} >= 0) ? 1 : (($_sahv_err //= "Must be at least 0"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"size_min"}) {
            $_sahv_dpath = [];
            # req #1
            ((defined($args->{"size_min"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"size_min"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
            
            &&
            
            (# clause: min
            (($args->{"size_min"} >= 0) ? 1 : (($_sahv_err //= "Must be at least 0"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: mtime_max"] if exists($args->{"mtime_max"}) && !defined($args->{"mtime_max"});
        return [400, "Missing required value for argument: mtime_min"] if exists($args->{"mtime_min"}) && !defined($args->{"mtime_min"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: size_max"] if exists($args->{"size_max"}) && !defined($args->{"size_max"});
        return [400, "Missing required value for argument: size_min"] if exists($args->{"size_min"}) && !defined($args->{"size_min"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls-dists") {
      FILL_FROM_POS: {
            1;
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"detail"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"detail"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"detail"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"include_dev"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"include_dev"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'bool'
            ((!ref($args->{"include_dev"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"include_nondev"} //= 1;
        if (exists $args->{"include_nondev"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"include_nondev"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'bool'
            ((!ref($args->{"include_nondev"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"newest"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"newest"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"newest"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"newest_n"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"newest_n"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"newest_n"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
            
            &&
            
            (# clause: min
            (($args->{"newest_n"} >= 1) ? 1 : (($_sahv_err //= "Must be at least 1"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required value for argument: include_dev"] if exists($args->{"include_dev"}) && !defined($args->{"include_dev"});
        return [400, "Missing required value for argument: include_nondev"] if exists($args->{"include_nondev"}) && !defined($args->{"include_nondev"});
        return [400, "Missing required value for argument: newest_n"] if exists($args->{"newest_n"}) && !defined($args->{"newest_n"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "ls-mods") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"modules"}) { return [400, "You specified --module but also argument #0"]; } else { $args->{"modules"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require List::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"detail"}) {
            $_sahv_dpath = [];
            # skip if undef
            (!defined($args->{"detail"}) ? 1 : 
            
            (# check type 'bool'
            ((!ref($args->{"detail"})) ? 1 : (($_sahv_err //= "Not of type boolean value"),0))))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"modules"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"modules"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"modules"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"modules"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"modules"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"modules"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"type"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"type"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"type"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required value for argument: modules"] if exists($args->{"modules"}) && !defined($args->{"modules"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: type"] if exists($args->{"type"}) && !defined($args->{"type"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "reindex") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require List::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            (# clause: min_len
            ((@{$args->{"files"}} >= 1) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Length must be at least 1"),0)))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "rm") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require List::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            (# clause: min_len
            ((@{$args->{"files"}} >= 1) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Length must be at least 1"),0)))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"protect_files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"protect_files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"protect_files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"protect_files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"protect_files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"protect_files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: protect_files"] if exists($args->{"protect_files"}) && !defined($args->{"protect_files"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "undelete") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require List::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            (# clause: min_len
            ((@{$args->{"files"}} >= 1) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Length must be at least 1"),0)))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    }    elsif ($sc_name eq "upload") {
      FILL_FROM_POS: {
            1;
            if (@ARGV > 0) { if (exists $args->{"files"}) { return [400, "You specified --file but also argument #0"]; } else { $args->{"files"} = [splice(@ARGV, 0)]; } }
        }
        my @check_argv = @ARGV;
        # fill from cmdline_src

        # fill defaults from "default" property and check against schema
        no warnings ('void');
        require Time::Duration::Parse::AsHash;
        require Scalar::Util;
        require List::Util;
        require Scalar::Util::Numeric::PP;
        my $_sahv_dpath;
        my $_sahv_err;
        if (exists $args->{"delay"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"delay"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # coerce rule(s): From_float::seconds, From_obj::datetime_duration, From_str::iso8601, From_str::human # coerce to: float(secs)
            (($args->{"delay"} = (!ref($args->{"delay"}) && $args->{"delay"} =~ /\A[0-9]+(?:.[0-9]+)\z/) ? [undef,$args->{"delay"}] : ((Scalar::Util::blessed($args->{"delay"}) && $args->{"delay"}->isa('DateTime::Duration')) ? [undef,($args->{"delay"}->years * 365.25*86400 + $args->{"delay"}->months * 30.4375*86400 + $args->{"delay"}->weeks * 7*86400 + $args->{"delay"}->days * 86400 + $args->{"delay"}->hours * 3600 + $args->{"delay"}->minutes * 60 + $args->{"delay"}->seconds + $args->{"delay"}->nanoseconds * 1e-9)] : ((!ref($args->{"delay"}) && $args->{"delay"} =~ /\AP(?:([0-9]+(?:\.[0-9]+)?)Y)? (?:([0-9]+(?:\.[0-9]+)?)M)? (?:([0-9]+(?:\.[0-9]+)?)W)? (?:([0-9]+(?:\.[0-9]+)?)D)? (?: T (?:([0-9]+(?:\.[0-9]+)?)H)? (?:([0-9]+(?:\.[0-9]+)?)M)? (?:([0-9]+(?:\.[0-9]+)?)S)? )?\z/x) ? [undef,(($1||0)*365.25*86400 + ($2||0)*30.4375*86400 + ($3||0)*7*86400 + ($4||0)*86400 + ($5||0)*3600 + ($6||0)*60 + ($7||0))] : ((!ref($args->{"delay"}) && $args->{"delay"} =~ /\d.*[a-z]/) ? (do { my $p; eval { $p = Time::Duration::Parse::AsHash::parse_duration($args->{"delay"}) }; my $err = $@; if ($err) { $err =~ s/ at .+//s; ["Invalid duration: $err"] } else { [undef, ($p->{years}||0) * 365.25*86400 + ($p->{months}||0) * 30.4375*86400 + ($p->{weeks}||0) * 7*86400 + ($p->{days}||0) * 86400 + ($p->{hours}||0) * 3600 + ($p->{minutes}||0) * 60 + ($p->{seconds}||0)] } }) : [undef,$args->{"delay"}])))), defined($args->{"delay"}->[0]) ? (($_sahv_err //= $args->{"delay"}->[0]), ($args->{"delay"} = $args->{"delay"}->[1]), '') : (($args->{"delay"} = $args->{"delay"}->[1]), 1))
            
            &&
            
            # check type 'duration'
            ((!ref($args->{"delay"}) && $args->{"delay"} =~ /\A[0-9]+(?:.[0-9]+)?\z/) ? 1 : (($_sahv_err //= "Not of type duration"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"files"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"files"})) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
            
            &&
            
            # check type 'array'
            ((ref($args->{"files"}) eq 'ARRAY') ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type array"),0))
            
            &&
            
            (# clause: min_len
            ((@{$args->{"files"}} >= 1) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Length must be at least 1"),0)))
            
            &&
            
            ([push(@{$_sahv_dpath}, undef), scalar(# clause: of
            ((!defined(List::Util::first(sub {!(
                        ($_sahv_dpath->[-1] = $_),
                        # req #0
                        ((defined($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Required but not specified"),0))
                        
                        &&
                        
                        # check type 'str'
                        ((!ref($args->{"files"}->[$_])) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))
                        )}, 0..@{$args->{"files"}}-1))) ? 1 : (($_sahv_err //= (@$_sahv_dpath ? '@'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . "Not of type text"),0))), pop(@{$_sahv_dpath})]->[1])
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"password"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"password"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"password"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"retries"} //= 5;
        if (exists $args->{"retries"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"retries"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'int'
            ((Scalar::Util::Numeric::PP::isint($args->{"retries"})) ? 1 : (($_sahv_err //= "Not of type integer"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        $args->{"subdir"} //= "";
        if (exists $args->{"subdir"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"subdir"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"subdir"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists
        if (exists $args->{"username"}) {
            $_sahv_dpath = [];
            # req #0
            ((defined($args->{"username"})) ? 1 : (($_sahv_err //= "Required but not specified"),0))
            
            &&
            
            # check type 'str'
            ((!ref($args->{"username"})) ? 1 : (($_sahv_err //= "Not of type text"),0))
            
            &&
            
            (# clause: match
            (($args->{"username"} =~ qr((?:(?-)\A\w{2,9}\z))) ? 1 : (($_sahv_err //= "Must match regex pattern \\A\\w{2,9}\\z"),0)))
            
            &&
            
            (# clause: max_len
            ((length($args->{"username"}) <= 9) ? 1 : (($_sahv_err //= "Length must be at most 9"),0)))
             ; if ($_sahv_err) { return [400, "Argument validation failed: $_sahv_err"] }
        } # if date arg exists

        # check required args
        return [400, "Missing required value for argument: delay"] if exists($args->{"delay"}) && !defined($args->{"delay"});
        return [400, "Missing required argument: files"] unless exists $args->{"files"};
        return [400, "Missing required value for argument: files"] if exists($args->{"files"}) && !defined($args->{"files"});
        return [400, "Missing required value for argument: password"] if exists($args->{"password"}) && !defined($args->{"password"});
        return [400, "Missing required value for argument: retries"] if exists($args->{"retries"}) && !defined($args->{"retries"});
        return [400, "Missing required value for argument: subdir"] if exists($args->{"subdir"}) && !defined($args->{"subdir"});
        return [400, "Missing required value for argument: username"] if exists($args->{"username"}) && !defined($args->{"username"});
        _pci_err([500, "Extraneous command-line argument(s): ".join(", ", @check_argv)]) if @check_argv;
        [200];
    } else { _pci_err([500, "Unknown subcommand1: $sc_name"]); }
}
1;

# END Local::_pci_check_args

### begin code_after_end
### end code_after_end


=head1 SYNOPSIS

First create a config file C<~/pause.conf> containing:

 username=<Your PAUSE ID>
 password=<Your PAUSE password>

or if you have C<~/.pause> from L<cpan-upload>, C<pause> can read it too
(encrypted C<.pause> is currently not supported).

Then:

 # upload one or more files
 % pause upload Foo-Bar-0.12.tar.gz Baz-2.24.tar.gz
 % pause upload Foo-Bar-0.12.tar.gz --subdir old/2014; # upload to a subdir

 # list your files
 % pause ls
 % pause ls 'App-*'; # accept filenames/wildcard patterns, note: quote first
 % pause ls -l     ; # see file sizes/mtimes/etc instead of just names

 # list your dists
 % pause ls-dists

 # delete files
 % pause rm Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause rm 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # undelete files scheduled for deletion (but not actually deleted yet)
 % pause undelete Foo-Bar-0.12.tar.gz Foo-Bar-0.12.readme Foo-Bar-0.12.meta
 % pause undelete 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # force reindexing
 % pause reindex Foo-Bar-0.12.tar.gz Foo-Bar-0.12.meta
 % pause reindex 'Foo-Bar-*'; # accept wildcard patterns, but quote first

 # clean old releases, by default will only leave the newest non-dev version
 % pause cleanup
 % pause cleanup -n 3 ; # keep 3 versions (newest + previous two)

To view permissions:

 # list all modules that you have permissions of
 % pause ls-mods
 % pause ls-mods -l ; # show detail

 # list all modules matching a wildcard
 % pause ls-mods -l 'Unix*'

 # list all modules you have co-maint of
 % pause ls-mods -l --type co-maint

To change permissions (not yet implemented):

 ...

To change your password (not yet implemented):

 ...

To view your account info (not yet implemented):

 ...

To change your email forwarding (not yet implemented):

 ...


=head1 append:FILES

F<~/.pause>


=head1 SEE ALSO

To clean up, there are also: L<pause-cleanup> (from L<App::PAUSE::cleanup>),
L<WWW::PAUSE::CleanUpHomeDir> (CLI in example).

=cut
